# .github/workflows/mikuexpo-monitor.yml
name: MikuExpo Ticket Status Monitor

on:
  schedule:
    # Check every 30 minutes
    - cron: '*/30 * * * *'
  workflow_dispatch: # Allow manual trigger

env:
  EXPECTED_STATUS: "Available"  # Change this to monitor for any specific text

jobs:
  monitor:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: |
        npm install puppeteer
        
    - name: Check ticket status
      id: check_status
      run: |
        cat > check_status.js << 'EOF'
        const puppeteer = require('puppeteer');
        const fs = require('fs');
        
        (async () => {
          const browser = await puppeteer.launch({
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
          });
          
          const page = await browser.newPage();
          
          try {
            console.log('Navigating to MikuExpo website...');
            await page.goto('https://mikuexpo.com/asia2025/', { 
              waitUntil: 'networkidle2',
              timeout: 30000 
            });
            
            // Wait for the element to be present
            await page.waitForSelector('#concert > div.section_inner > div.concert_list_wrapper > div > ul > li:nth-child(4) > div.ticket > div > p', {
              timeout: 10000
            });
            
            // Get the text content
            const ticketStatus = await page.evaluate(() => {
              const element = document.querySelector('#concert > div.section_inner > div.concert_list_wrapper > div > ul > li:nth-child(4) > div.ticket > div > p');
              return element ? element.textContent.trim() : null;
            });
            
            console.log(`Current ticket status: "${ticketStatus}"`);
            
            // Read previous status if it exists
            let previousStatus = process.env.EXPECTED_STATUS || 'Coming Soon';
            if (fs.existsSync('previous_status.txt')) {
              previousStatus = fs.readFileSync('previous_status.txt', 'utf8').trim();
            }
            
            console.log(`Previous status: "${previousStatus}"`);
            console.log(`Expected status to watch for: "${process.env.EXPECTED_STATUS}"`);
            
            // Save current status
            fs.writeFileSync('previous_status.txt', ticketStatus || '');
            
            // Check if current status matches expected status but previous status was different
            // OR if current status is different from expected status but previous status matched
            const expectedStatus = process.env.EXPECTED_STATUS || 'Coming Soon';
            
            if (ticketStatus === expectedStatus && previousStatus !== expectedStatus) {
              console.log(`üö® STATUS CHANGED TO EXPECTED! Status changed to "${expectedStatus}"`);
              console.log(`Previous status: "${previousStatus}"`);
              
              // Write to GitHub Actions output file
              const fs = require('fs');
              const outputFile = process.env.GITHUB_OUTPUT;
              if (outputFile) {
                fs.appendFileSync(outputFile, `STATUS_CHANGED=true\n`);
                fs.appendFileSync(outputFile, `NEW_STATUS=${ticketStatus}\n`);
                fs.appendFileSync(outputFile, `PREVIOUS_STATUS=${previousStatus}\n`);
              }
              
              process.exit(0);
            } else if (ticketStatus !== expectedStatus && previousStatus === expectedStatus) {
              console.log(`üö® STATUS CHANGED FROM EXPECTED! Status changed from "${expectedStatus}" to "${ticketStatus}"`);
              
              // Write to GitHub Actions output file
              const fs = require('fs');
              const outputFile = process.env.GITHUB_OUTPUT;
              if (outputFile) {
                fs.appendFileSync(outputFile, `STATUS_CHANGED=true\n`);
                fs.appendFileSync(outputFile, `NEW_STATUS=${ticketStatus}\n`);
                fs.appendFileSync(outputFile, `PREVIOUS_STATUS=${previousStatus}\n`);
              }
              
              process.exit(0);
            } else if (ticketStatus) {
              console.log(`No change detected. Current: "${ticketStatus}", Expected: "${expectedStatus}"`);
              // Write to GitHub Actions output file
              const fs = require('fs');
              const outputFile = process.env.GITHUB_OUTPUT;
              if (outputFile) {
                fs.appendFileSync(outputFile, `STATUS_CHANGED=false\n`);
              }
            } else {
              console.log('‚ö†Ô∏è  Could not find the element or get its text');
              process.exit(1);
            }
            
          } catch (error) {
            console.error('Error:', error);
            process.exit(1);
          } finally {
            await browser.close();
          }
        })();
        EOF
        
        node check_status.js
        
    - name: Commit status file
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add previous_status.txt
        git diff --staged --quiet || git commit -m "Update ticket status tracking"
        git push
        
    - name: Send Slack notification
      if: steps.check_status.outputs.STATUS_CHANGED == 'true'
      run: |
        curl -X POST -H 'Content-type: application/json' \
        --data "{
          \"text\": \"üé´ MikuExpo Ticket Status Changed!\",
          \"blocks\": [
            {
              \"type\": \"header\",
              \"text\": {
                \"type\": \"plain_text\",
                \"text\": \"üé´ MikuExpo Ticket Status Update\"
              }
            },
            {
              \"type\": \"section\",
              \"fields\": [
                {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Previous Status:*\n${{ steps.check_status.outputs.PREVIOUS_STATUS }}\"
                },
                {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*New Status:*\n${{ steps.check_status.outputs.NEW_STATUS }}\"
                }
              ]
            },
            {
              \"type\": \"section\",
              \"text\": {
                \"type\": \"mrkdwn\",
                \"text\": \"üéâ *Tickets might be available now!*\n\n<https://mikuexpo.com/asia2025/|Check MikuExpo Website>\"
              }
            },
            {
              \"type\": \"context\",
              \"elements\": [
                {
                  \"type\": \"mrkdwn\",
                  \"text\": \"Checked at: $(date -u)\"
                }
              ]
            }
          ]
        }" \
        ${{ secrets.SLACK_WEBHOOK_URL }}
        
    - name: Send Telegram notification
      if: steps.check_status.outputs.STATUS_CHANGED == 'true'
      run: |
        MESSAGE="üé´ *MikuExpo Ticket Status Changed!*
        
        üìã *Previous Status:* ${{ steps.check_status.outputs.PREVIOUS_STATUS }}
        ‚ú® *New Status:* ${{ steps.check_status.outputs.NEW_STATUS }}
        
        üéâ Tickets might be available now!
        
        üîó [Check MikuExpo Website](https://mikuexpo.com/asia2025/)
        
        ‚è∞ Checked at: $(date -u)"
        
        curl -X POST \
        -H 'Content-Type: application/json' \
        -d "{\"chat_id\": \"${{ secrets.TELEGRAM_CHAT_ID }}\", \"text\": \"$MESSAGE\", \"parse_mode\": \"Markdown\", \"disable_web_page_preview\": false}" \
        https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage